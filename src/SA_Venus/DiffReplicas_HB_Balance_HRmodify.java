package SA_Venus;

/**
 * 算法流程
 * 方案A：
 * 第一步：用SA算法得到状态目标函数值近似最小的一个集合，分流用最小HB策略，状态的目标函数值为：HB&BlancePenalty
 * 第二步：计算这个小集合里的HR，取用HR最小的那个状态
 *
 * 方案B：
 * 用SA算法得到状态目标函数值近似最小的一个集合，分流用最小HR策略，状态的目标函数值为：HR&BlancePenalty
 *
 * 比较：
 * 方案A
 * Pros: 按照HB的block粒度来对查询分流理论上会比HR的row粒度更容易得到负载均衡的解
 * 比如副本1,2,3，假设它们的HB都是最小的，HR从高到底，如果按照方案A，这就是一个最优解，
 * 如果按照方案B，根据HR最小的分流原则，所有查询导到副本3，结果该状态的代价除了最小的HR之外，还要加上因为基于HR最小策略分流导致的不均衡代价，
 * 从而使得这个状态就被几乎pass了，而这个方案很可能和最优解没有太大差别。
 *
 * Cons:
 *
 * 思考：是否可以把分流用HB，状态目标函数值用HR？
 * 分流用粗粒度的HB，理想上倾向于得到比HR更均衡的负载，
 * 状态目标函数值=最小HB策略查询分流后的HR+BalancePenalty，理想上倾向于得到比HB+BP&HR收尾的两步式方法更小的状态解，
 * 这是因为HB粒度比较粗，SA搜索到的近似最小HB解集合里HR是近似最小的概率可能不如直接SA找HR来得高。
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class DiffReplicas_HB_Balance_HRmodify {
}
